---
layout: post
title: Goals
---

Over the years I've written quite a bit of software. Some of it has been great, and some of it has been not so great. There have been a few core things I've noticed when looking at what has distinguised my software from being good or bad.

- Not being cute (AKA simplicity)
- Using the core language you are writing in
- Immutable data structures

First, let's address "Not being cute". I’ve see this happen in a lot of different places I've worked. A solution has been done in such a “clever” way that it takes way longer than it should for an average developer to grok it. There is a time and a place to be cute, but when you are working on a large team it should be a conscious effort to write code with the expectation that other humans are going to read it. Again - you are first and foremost writing for humans -- not the computer. This is why we program in higher level languages. Only when this contradicts the need for greater performance should this be violated.

Secondly, useing the core language you are writing in. I've run into many projects that unnecesarily pull in vasts amounts of non-core language libraries to solve relatively simple problems. Libraries can provide a wonderful abstraction or interface for a problem set you may have, but they are not a silver bullet. Libraries have a lot of baggage that comes along with them. Will this library be supported for the forseeable future? Can I easily extend it? What is the code quality of the library? This library have solved my problem, but is it worth pulling this whole thing in here? Can I write the functionality I need and be more simple about it? Do not pull in libraries willy-nilly. You need to vet them and you first need to see if its even worth bringing in this whole interface. Can I just write what I need myself and make it more simple for the rest of my team?

And finally, immutable data structures. By now, unless you live under a rock, you've seen all the rage about functional programming. I plan on writing more posts about it in the future on topics such as purity, higher order functions, lambdas, recursion, etc -- but I digress. One of the most important concepts in functional program is the idea of immutability. Besides the infamous null pointer exception, unsupervised state change (mutation) has to be up there as one of the top ways to create crap software. The easiest way I like to think about an immutable program is kind of like a list of states. Each state represents a moment in time within the program that was calculated. Rather than maintaining a reference to a state and directly updating that state, you are simply deriving new state from old state. In this way you are never using a reference to a single volatile state. This becomes incresingly important with parellel computing with threads. Constructs like mutex can be very costly and detrimental to processing things efficiently. State as a series of step rather than a single volatile reference to state can be applied to threading and distributed computing as well. Models such as the [Actor Model](https://en.wikipedia.org/wiki/Actor_model) can help with this. In a later post I plan on talking about a specific implementation of this using Scala and Akka.
