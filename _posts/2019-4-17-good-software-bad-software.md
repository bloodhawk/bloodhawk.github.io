Over the years I've written quite a bit of software. Some of it has been great, and some of it has been not so great. There have been a few core things I've noticed when looking at what has distinguished my software from being good or bad.

- Not being cute (AKA simplicity)
- Using the core language you are writing in
- Immutable data structures

First, let's address "Not being cute". I’ve seen this happen in a lot of different places I've worked. A solution has been done in such a “clever” way that it takes way longer than it should for an average developer to grok it. There is a time and a place to be cute, but when you are working on a large team it should be a conscious effort to write code with the expectation that other humans are going to read it. Again - you are first and foremost writing for humans -- not the computer. This is why we program in higher level languages. Only when this contradicts the need for greater performance should this be violated.

Secondly, using the core language you are writing in. I've run into many projects that unnecessarily pull in vasts amounts of non-core language libraries to solve relatively simple problems. Libraries can provide a wonderful abstraction or interface for a problem set you may have, but they are not a silver bullet. Libraries have a lot of baggage that comes along with them. Will this library be supported for the foreseeable future? Can I easily extend it? What is the code quality of the library? This library has solved my problem, but is it worth pulling this whole thing in here? Can I write the functionality I need and be more simple about it? Do not pull in libraries willy-nilly. You need to vet them and you first need to see if it's even worth bringing it in. Can I just write what I need myself and make it more simple for the rest of my team?

And finally, immutable data structures. By now, unless you live under a rock, you've seen all the rage about functional programming. I plan on writing more posts about it in the future on topics such as functors, monads, purity, higher order functions, lambdas, recursion, etc -- but I digress. One of the most important concepts in functional programming is the idea of immutability. Besides the infamous null pointer exception, unsupervised state change/mutation has to be up there as one of the top ways to create crap software. The easiest way I like to think about an immutable program is kind of like a list of states. Each state represents a moment in time within the program that was calculated. Rather than maintaining a reference to a state and directly updating that state, you are simply deriving new state from the old state. In this way, you are never using a reference to a single volatile state. This becomes increasingly important with parallel computing when using threads. Constructs like a mutex can be a very costly and detrimental way to process things efficiently. States as a series of steps rather than a single volatile reference to a state can be applied to threading and distributed computing as well. Models such as the [Actor Model](https://en.wikipedia.org/wiki/Actor_model) can help with this. In a later post, I plan on talking more about a specific implementation of this using Scala and Akka. Until then, look for opportunities to solve your problems in an immutable way.
